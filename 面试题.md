# 面试题

## html

#### **1、html语义化的作用**

​	增强代码的可读性，清晰的代码结构，有利于seo，方便开发和维护

#### **2、html新标签**

​	canvas footer header nav video等

## CSS

#### **1、标准盒子模型和怪异盒子模型**

​	标准盒子模型：content+padding+border

​	怪异盒子模型：content+border+padding+margin

![image.png](https://s2.loli.net/2022/03/20/Qg3wn17zNHjrpMB.png)

​	



```html
<style>
  .content_box {
    /* 整个box宽度为160，content宽度为 100 */ box-sizing: content-box;
    /* 整个box宽度为100，content宽度为 40 */ box-sizing: border-box;
    border: 10px solid red;
    background-color: yellow;
    padding: 20px;
    margin: 10px;
    width: 100px;
    height: 100px;
  }
</style>

<body>
  <div class="content_box">
  </div>
</body>
```

content-box

![image.png](https://s2.loli.net/2022/03/20/q9wtpYGgsBhUeQN.png)

border-box

![image.png](https://s2.loli.net/2022/03/20/DamHyUQSR3XAM4P.png)

#### **3、rem和em的区别**

​	rem是相对于根元素的font-size，

​	em是相对于父元素的font-size

#### **4、css常用的选择器有哪些**

​	类选择器，伪类选择器，id选择器，后代选择器， 元素选择器，属性选择器

#### **5、css选择器的权重**

​	!import > 行内 > id > 类(.) > 元素和伪类 > * 

#### **6、行内元素和块级元素**

​	行内元素不能设置宽高，宽高是由内容来决定的。例如span，input

​	块级元素宽度是由父级元素决定的，独占一行，可以设置宽高。例如p div

#### **7、什么是BFC**

​	BFC格式化上下文，他在页面上创建一个独立的渲染区域，让在BFC内的元素和外部元素互不干扰，

​	产生BFC的方式

​		float：除none外

​		overflow： hidden

​		position： absolute和fixed

​	可以解决边距重叠问题，文字环绕图片，浮动引起的高度塌陷问题

#### **8、水平垂直居中**

​	flex： 

```css
display:flex
just-content:center
align-item:center
```

#### **9、多行文本省略**

```html
<style>
  .sl {
    width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }
  .dh {
    width: 100px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
</style>

<body>
  <div class="dh">
    adsadshaah和吉萨活动i啊我回答了哇好哇好棒覅八十看来办法了吧立法 a
  </div>
  <div class="sl">
    adsadshaah和吉萨活动i啊我回答了哇好哇好棒覅八十看来办法了吧立法
  </div>
</body>
```

#### **10、link和@import的区别**

​	@import是css提供的，只能导入样式列表，link是html提供的标签，不仅可以加载css，还可以定义rs

​	加载页面时候，link引入的css标签会被同时加载，而@import是在css加载完成之后才会被加载

## JavaScript

**1、js基本数据类型**

​	null, number, undefined, string, boolean, symbol, bigint

```js
map: 遍历数组，返回回调返回值组成的新数组
    var arr = [1, 2, 3, 4, 5, 6, 7];
    const mapArr = arr.map((item) => {
      return item + 1;
    });
console.log(mapArr); // [  2, 3, 4, 5,  6, 7, 8]
forEach: 无法break，可以用try/catch中throw new Error来停止
    let foreachArr = [];
    arr.forEach((item) => {
      try {
        if (item === 4) throw new Error("123");
        foreachArr.push(item * 2);
      } catch (e) {
        console.log(e);
      }
    });
    console.log(foreachArr); // [ 2, 4, 6, 10, 12, 14 ]
filter: 过滤
    var arr = [1, 2, 3, 4, 5, 6, 7];
    var arr2 = [3, 5, 7, 9];
	// includes可以来判断是否有nan,includes会认为空的值为undefined
    const newarr = arr.filter((item) => {
      return arr2.indexOf(item) !== -1;
    });
    console.log(newarr);
some: 有一项返回true，则整体为true
    var arr = [1, 2, 3, 4, 5, 6, 7];
    const newarr = arr.some((item) => {
      return item % 2 === 0;
    });
	console.log(newarr); // true
every: 有一项返回false，则整体为false
    var arr = [1, 2, 3, 4, 5, 6, 7];
    const newarr = arr.every((item) => {
      return item % 2 === 0;
    });
    console.log(newarr); // false
join: 通过指定连接符生成字符串
    var arr = [1, 2, 3, 4, 5, 6, 7];
    console.log(arr.join("-")); // 1-2-3-4-5-6-7
push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】
    var arr = [1, 2, 3];
    arr.push(1);
    console.log(arr); //[ 1, 2, 3, 1 ]
    arr.pop()
    console.log(arr); //[ 1, 2, 3 ]
unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】
    var arr = [1, 2, 3];
    arr.shift();
    console.log(arr); //[  2, 3 ]
    arr.unshift(3);
    console.log(arr); //[ 3, 2, 3 ]
sort(fn) / reverse: 排序与反转，改变原数组
	var arr = [2, 5, 123, 521, 1, 65536];
	arr.reverse(); // [ 65536, 1, 521, 123, 5, 2 ]
    const sortArr = arr.sort((a, b) => {
      return a - b;
    });
    console.log(sortArr); // [ 1, 2, 5, 123, 521, 65536 ]
concat: 连接数组，不影响原数组， 浅拷贝
    var arr = [2, 5];
    var arr2 = [1, 2, 3];
    const newArr = arr.concat(arr2);
    console.log(newArr); // [ 2, 5, 1, 2, 3 ]
slice(start, end): 返回截断后的新数组，不改变原数组
    var arr = [2, 5, 5, 7645, 12, 5];
    const newArr = arr.slice(1, 2);
    console.log(arr, newArr); // [ 2, 5, 5, 7645, 12, 5 ] [ 5 ]
splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组
var arr = [2, 5, 5, 7645, 12, 5];
    const newArr = arr.splice(1, 2);//被截断的数组
    console.log(arr, newArr); //[ 2, 7645, 12, 5 ]  [ 5, 5 ]
indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标
    var arr = [2, 5, 5, 7645, 12, 5];
    console.log(arr.indexOf(5)); // 1，只获取第一次获取到
console.log(arr.lastIndexOf(5)); // 5 获取最后一次获取到，fromIndex从哪一位向前搜索
reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)
    var arr = [2, 5, 5, 7645, 12, 5];
    const result = arr.reduce((prev, next) => {
      return prev + next;
    });
    console.log(result); // 7674
	// 从右边开始
    function appendCurrent (previousValue, currentValue) {
        return previousValue + "::" + currentValue;
    }
    var elements = ["abc", "def", 123, 456];
    var result = elements.reduceRight(appendCurrent);
    document.write(result); //456::123::def::abc
```

#### **2、get和post参数问题**

​	http协议没有规定get和post参数长度,get的最大长度显示是因为浏览器和web服务器限制了uri的长度.

​	get和post在缓存方面, get请求类似于查找过程,用户获取数据,可以不用每次与数据库相连,可以使用缓存. post不同,post一般用于修改和删除的工作,必须和数据库进行交互,不能使用缓存

#### **3、什么是闭包**

​	函数中使用函数外部的变量,该函数被称为闭包

​	闭包可能会导致内存泄漏问题,函数使用了函数外部的变量,那个变量不会被垃圾回收机制回收.

​	闭包可以避免全局变量的污染.

```js
for(var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
} // 333
// 是用let的话,let会和每个代码块形成块级作用域,在打印的时候会找块级作用域中的变量,从而输出0 1 2

```

#### **4、垃圾回收机制**

js垃圾回收机制分为两中,引用计数和标记清除

​	引用计数的话,他为在内存中的每一个对象保存一个计数器,如果有其它对象指向它,则计数加一,指向删除,计数减一,当计数等于0的时候,该对象就会被当初垃圾回收. 该方法, 如果存在两个对象相互引用的时候,则这两个对象会被一直存在内存中,不会被销毁, 会存在问题

​	标记清除, 先建立各个对象之间的关联,会从根节点开始, 标记每个节点上的对象,若没有在这个结构上的,则会被垃圾回收机制回收.

#### **5、js作用域和作用域链**

​	js中作用域分为全局作用域和函数作用域

​	作用域链,在查找一个变量的时候在当前作用域中没有找到, 则会去他上层的作用域中查找,如果上层也没有,则一个个找上去, 这样形成的链条,则成为作用域链

#### **6、js原型域和原型链**

​	js中每个对象内部都存在一个属性, 就是prototype(原型),新建的对象没有prototype属性,他存在\_\_proto\_\_属性指向Object.prototype(若他是new Object 或者 {} 出来的), Function的prototype执行Object的prototype,function Function()中Function作为对象,他的\_\_proto\_\_指向Function的prototype,Function的构造函数又指向function Function()

```js
console.log(Object.prototype); 
//Object{}
var o = new Object();
console.log(o.prototype);  //undefined
console.log(Array.prototype); 
//[Symbol(Symbol.unscopables): Object]
console.log(Function.prototype); 
//function(){}
function hello(){
console.log("hello");
}
hello.prototype = "hello world";
console.log(hello.prototype); 
//hello world
```

![ad7fd7e87915dd455dd64e4543ef7b4.jpg](https://s2.loli.net/2022/03/20/uCRFsoTWcg4wbQZ.jpg)

什么是原型链, js中每个对象都有一个指向它原型对象的内部链接,而这个原型对象又存在自己的原型,知道某个对象的原型为null为止,这种链式结构就是原型链

#### **6、模块化**

​	AMD: 异步模块化, require.js, 在使用模块前要将依赖模块全部加载完毕

​	CMD: seaJS

​	commonJS: 一个单独的文件就是一个单独的模块, 文件中的作用域独立,文件中定义的变量无法被外部使用,

通过module.exports导出所需要的内容对象, 通过require来加载

​	es6: 类似于commonjs,能够支持异步加载和配置模块加载,使用export到处, import导入

##### 	**为什么需要模块化开发**

​		高内聚低耦合,有利于团队开发,可重用,方便维护

#### **7、图片的预加载和懒加载**

​	预加载: 图片提前加载,当用户需要查看时候,可直接从本地缓存中渲染,

​	懒加载: 主要作为服务器前端优化,减少请求次数或延迟请求数量

​		图片懒加载的方式: 

​			先是把所有的图片使用一张占位图进行占位, 给图片一个data-src, 将请求过来的图片数据存入.当页面加载完毕, 判断图片是否在页面可视窗口上,若在取出data-src中的数据存入src中,图片显示

#### **8、手写promise**

```js
let status_pending = "pending"
let status_resolve = "resolve"
let status_reject = "reject"
class MyPromise{
	constructor(executor){
		this.status = status_pending
        this.reason;
        this.value;
        this.onfulfilledFns = []
        this.onrejectedFns = []
        const resolve = (value) => {
            if(this.status = status_pending) {
                queueMicrotask(()=>{
                	this.status = status_resolve
                    this.value = value
                    this.onfulfilledFns.foreach(fn=>{
                        fn()
					})
            	})
            }
        }
        const reject = (reason) => {
            if(this.status = status_pending) {
                queueMicrotask(()=>{
                	this.status = status_reject
                    this.reason = reason
                    this.onrejectedFns.foreach(fn=>{
                        fn()
					})
            	})
            }
        }
    	executor(resolve, reject)
    }
    then(onfulfilled, onrejected) {
        return new MyPromise((resolve, reject)=>{
			if(this.status === status_pending){
				this.onfulfilledFns.push(()=>{
					const result = onfulfilled(this.value)
                    try{
						resolve(result)
                    } catch {
                        reject(result)
                    }
                })
                this.onrejectedFns.push(()=>{
					const result = onrejected(this.reason)
                    try{
						resolve(result)
                    } catch {
                        reject(result)
                    }
                })
            }
            if(this.status === status_resolve){
				const result = onfulfilled(this.value)
                    try{
						resolve(result)
                    } catch {
                        reject(result)
                    }
            }
            if(this.status === status_reject){
				const result = onrejected(this.reason)
                    try{
						resolve(result)
                    } catch {
                        reject(result)
                    }
            }
        })
    }
    finally(fn){
		this.then(()=>{
            fn()
        },()=>{
            fn()
        })
    }
    catch(reject){
		this.then(undefined,reject)
    }
    resolve(value){
		return new MyPromise((resolve, reject)=>{
            resolve(value)
        })
    }
    reject(reason){
		return new MyPromise((resolve, reject)=>{
            reject(reason)
        })
    }
    all(promises){
        return new MyPromise((resolve,reject)=>{
            let result = []
            promises.foreach(item=>{
				item.then(res=>{
					result.push(res)
                    if(result.length === promises.length){
						resolve(result)
                    }
                }, err=>{
                    reject(err)
                })
            })
        })
    }
    allSettled(promises){
        return new MyPromise((resolve,reject)=>{
            let result = []
            promises.foreach(item=>{
				item.then(res=>{
					result.push({flag: true,res})
                    if(result.length === promises.length){
						resolve(result)
                    }
                }, err=>{
                    result.push({flag: false, res})
                    if(result.length === promises.length){
						resolve(result)
                    }
                })
            })
        })
    }
    any(promises){
        return new MyPromise((resolve,reject)=>{
            let result = []
            promises.foreach(item=>{
				item.then(res=>{
					resolve(result)
                }, err=>{
                    result.push({flag: false, res})
                    if(result.length === promises.length){
						reject(result)
                    }
                })
            })
        })
    }
    race(promises){
        return new MyPromise((resolve,reject)=>{
            let result = []
            promises.foreach(item=>{
				item.then(res=>{
					resolve(result)
                }, err=>{
					reject(result)
                })
            })
        })
    }
}
```

#### **8、this**

​	this总是指向函数的直接调用者, 如果又new关键字,this指向new出来的那个对象

​	this绑定规则

​		1 默认绑定

```js
// 默认绑定
function foo() {
  console.log(this)
}

//独立函数调用，指向windows
foo()
function foo() {
  console.log(this)
}
var obj = {
  name : 'qzf',
  foo: foo
}

var bar = obj.foo

bar() // windows
```

​	2 隐式绑定

```js
var obj2 = {
  name: "qzf",
  foo: function () {
    console.log(this);
  },
};

var obj3 = {
  name: "qzf",
  bar: obj2.foo,
};

obj3.bar(); // obj3
```

 3 显示绑定

```js
function foo() {
  console.log('函数被调用了')
}
// foo直接调用和call、apply调用的不同在于this指向的不同，
// foo()  指向window
// foo函数上有有个call，来调用foo函数

var obj = {
  name: 'qzf'
}

// call和apply可以指定this的绑定对象
foo.call(obj)
foo.apply(obj)

// call和apply的区别
function sum(num1, num2){
  console.log(num1 + num2 , this)
}

sum.call("call", 20, 30)
sum.apply("apply", [20,30])

// 3、call和apply在执行函数的时候是可以明确绑定this的，这个就是显示绑定
```

new 绑定

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

var p1 = new Person("qzf", 19);
console.log(p1.name, p1.age);

var p2 = new Person("kobe", 22);

function a() {
  return () => {
    return () => {
      console.log(this);
    };
  };
}
console.log(a()()());
```

#### 9、事件循环

​	js是一个单线程的应用程序，页面渲染，函数处理都在这个主线程上执行，还存在一个工作线程，这个线程可能存在浏览器或js引擎中，处理网络请求等异步操作，

​	当我们执行一个js文件的时候，任务进入任务队列，判断任务是否是异步任务，不是直接运行，若是异步任务则放入任务队列中，直到主线程中不存在任务，开始执行微任务队列，微任务队列开始执行，若不是异步操作，直接执行，若有微任务则加入微任务队列，若出现红任务，则加入红任务队列，依次执行。全部执行完成后才会红任务队列，

# Vue

#### 1、vue的生命周期

​	vue实例从创建到销毁的过程就是vue的生命周期，也就是从开始创建，初始化数据，编译模板，挂在dom 渲染，更新等一系列操作

​	vue的生命周期包括，beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestory, destory等

​	dom元素的渲染在mounted中完成 

#### 2、v-show和v-if区别

v-show是通过display block none来对元素进行显示和隐藏的

v-if是通过对元素进行销毁和创建，来对元素进行显示和隐藏的

#### 3、组件之间的传值

​	**父子组件传值**

```vue
<template>
    <child :msg="message"  @msgFunc="func"></child>
</template>

<script>
import child from './child.vue';
export default {
    components: {
        child
    },
    data () {
        return {
            message: 'father message';
        }
    },
    methods: {
        func (msg) {
            console.log(msg);
        }
    }
}
</script>
// 子=========================================
<template>
    <div>{{msg}}</div>
	<button @click="handleClick">点我</button>
</template>

<script>
export default {
    props: {
        msg: {
            type: String,
            required: true
        }
    },
    methods () {
        handleClick () {
            //........
            this.$emit('msgFunc');
        }
    }
}
</script>

```

非父子组件传值，eventBus

手写**eventBus**

```js
class eventBus {
    constructor(){
		this.eventBus = {}
    }
    on(eventNames, eventCallback, thisArg) {
        let handlers = this.eventBus[eventNames]
        if(!handlers) {
            let handers = []
            this.eventBus[eventNames] = handers
        }
        handers.push({eventCallback, this})
    }
    off(eventNames,eventCallback) {
        let handlers = this.eventBus[eventNames]
        if(!handlers) {
           return
        }
        let newHandlers = [...handlers]
        for(let i = 0; i<newHandlers.length; i++){
			let handler = newHandlers[i]
            if(handler.eventCallback === eventCallback){
				const index = handlers.indexOf(handler);
       			handlers.splice(index, 1);
            }
        }
    }
    emit(eventNames,...plyload){
		let handlers = this.eventBus[eventNames]
        if(!handlers) {
           return
        }
        handers.foreach(fn=>{
            fn.eventCallback.apply(fn.thisArg, plyload)
        })
    }
}
```

#### 4、MVVM

```html
M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑

V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来

VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View

```

#### 5、key

​	vue中key是作为虚拟节点的唯一标识，通过这个keydiff算法能够更加快速准确的更新数据

​	没有key的时候： 

​			获取新旧node，得到新旧node的长度，获取到最短的node，然后进行遍历，进行patch比较，遇到不一样的，则进行更新。便利完成之后，如果新的大于旧的，则新增挂在节点，旧的比新的多的话，则卸载掉后面的。

​	存在key的时候：

​			获取到新旧node，通过while循环，获取新旧node的key和type进行比较，遇到不同的则从新旧node数组中尾部重新开始遍历，直到遇到不同的，跳出循环，如果新节点较多，则进行挂载操作，旧节点较多，则进行卸载操作。如果新旧节点长度一样，但是内部顺序不一样的话，尽可能的在旧node中找到新node中所要的node，放到索要的位置。

#### 6、v-model

​	v-model在vue2中

```vue
<input v-model="any">
<!--实际上就是绑定了一个value，然后接收一个input事件，那么他传递下去的值必须是value,接收的时间也必须是input事件-->
<input v-bind:value="any" v-on:input="any=$event.target.value">
```

​	vue2.2中映入了modal组件选项

```vue
<ChildComponent v-model="title" />

<script>
    // 子组件中
export default {
  model: {
    prop: 'title',   // v-model绑定的属性名称
    event: 'change'  // v-model绑定的事件
  },
  props: {

    value: String,   // value跟v-model无关
    title: {         // title是跟v-model绑定的属性
      type: String,
      default: 'Default title'
    }
  }
}
</script>
```

​	vue3

```vue
<input :modelValue="title"  @update:modelValue = "title = $event">
<script>
    // 子组件中
export default defineComponent({
    name:"ValidateInput",
    props:{
        modelValue:String,   // v-model绑定的属性值
    },
    setup(){
        const updateValue = (e: KeyboardEvent) => {
          context.emit("update:modelValue",targetValue);   // 传递的方法
        }
    }
}
</script>
```

#### 7、nextTick()

​	next就是在更新结束后，延迟执行这个回调，在修改数据之后，使用这个方法，能够获取到最新的视图







